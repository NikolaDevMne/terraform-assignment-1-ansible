name: Terraform CI/CD

on:
  push:
    branches:
      - main
    paths:
      - '**/*.tf'
      - '.github/workflows/terraform.yml'

  pull_request:
    branches:
      - main
    paths:
      - '**/*.tf'
      - '.github/workflows/terraform.yml'

env:
  AWS_REGION: eu-central-1
  TERRAFORM_VERSION: 1.11.0
  WORKING_DIR: infra/terraform

permissions:
  id-token: write
  contents: read    

jobs:
  terraform_plan:
    name: Terraform Plan
    runs-on: ubuntu-latest

    if: github.event_name == 'pull_request'

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{env.TERRAFORM_VERSION}}

      - name: Terraform Init
        working-directory: ${{ env.WORKING_DIR }}
        run: terraform init -input=false -upgrade
      
      - name: Terraform FMT
        working-directory: ${{ env.WORKING_DIR }}
        run: terraform fmt -recursive

      - name: Terraform Validate
        working-directory: ${{ env.WORKING_DIR }}
        run: terraform validate

      - name: Terraform Plan
        id: plan
        working-directory: ${{ env.WORKING_DIR }}
        run: terraform plan -var="ssh_public_key=${{ secrets.SSH_PUBLIC_KEY }}"

  terraform_apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{env.TERRAFORM_VERSION}}

      - name: Terraform Init
        working-directory: ${{ env.WORKING_DIR }}
        run: terraform init -input=false -upgrade
      
      - name: Terraform FMT
        working-directory: ${{ env.WORKING_DIR }}
        run: terraform fmt -recursive

      - name: Terraform Validate
        working-directory: ${{ env.WORKING_DIR }}
        run: terraform validate

      - name: Terraform Plan
        id: plan
        working-directory: ${{ env.WORKING_DIR }}
        run: terraform plan -out=tfplan -var="ssh_public_key=${{ secrets.SSH_PUBLIC_KEY }}"

      - name: Terraform Apply
        working-directory: ${{ env.WORKING_DIR }}
        run: terraform apply -auto-approve tfplan
        
      - name: Capture Terraform outputs
        id: tfout
        working-directory: infra/terraform
        run: |
          echo "INSTANCE_PUBLIC_IP=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT

      - name: Start ssh-agent and add key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Ansible
        run: |
          python -m pip install --upgrade pip
          pip install ansible

      - name: Render static inventory
        working-directory: infra/ansible
        env:
          INSTANCE_PUBLIC_IP: ${{ steps.tfout.outputs.INSTANCE_PUBLIC_IP }}
        run: |
          mkdir -p inventories
          cat > inventories/hosts.ini <<EOF
          [web]
          ${INSTANCE_PUBLIC_IP} ansible_user=ubuntu ansible_ssh_private_key_file=~/.ssh/deploy_key
          EOF
          echo "Inventory:"
          cat inventories/hosts.ini

      - name: Run Ansible playbook
        working-directory: infra/ansible
        run: ansible-playbook -i inventories/hosts.ini playbooks/site.yml

      - name: Health check
        run: |
          set -e
          IP=${{ steps.tfout.outputs.INSTANCE_PUBLIC_IP }}
          for i in {1..12}; do
            code=$(curl -s -o /tmp/h -w "%{http_code}" "http://$IP/")
            if [ "$code" = "200" ]; then
              echo "OK"; exit 0
            fi
            sleep 5
          done
          echo "Health check failed"; cat /tmp/h || true; exit 1
